# PY110 Notes and Study Material

## Collections and Sequences

### Operations on Sequences

- Slicing: syntax for slicing is `sequence[start:stop:step]`
- stop index is not included in the slice
- If ommitted, start defaults to 0 for positive steps and -1 for negative step values

~~~Python
>>> lst = [0, 1, 2]

>>> # Omitting start with a positive step
>>> lst[::1]
[0, 1, 2]

>>> tup = (0, 1, 2)
>>> # Omitting start with a negative step
>>> tup[::-1]
(2, 1, 0)

>>> # For ranges, the start parameter works similarly:
>>> r = range(10)
>>> list(r[2:])
[2, 3, 4, 5, 6, 7, 8, 9]
~~~

- If stop index ommitted it will go up to the end of the sequence
- If start is greater than stop, the result is an empty sequence
- If step negative, empty sequence returned when stop is greater than start
- Note that my_list[::] is equivalent to my_list[:]. Both expressions yield a shallow copy of a list. This is considered pythonic or idiomatic code, so it's seen often.
- strings are sequences of characters so we iterate over them char by char:

~~~Python
>>> message = "bye"
>>> for char in message:
...    print(char)
...
b
y
e
~~~

- While loops are often used when you need the index of each item
- More idiomatic to use the enumerate function for this purpose

- You cannot concatenate ranges

- `sequence.count(value)` returns the number of occurrences of a value in the sequence
- `sequence.index(value)` returns the index of the first occurrence of a value in the sequence - if not present, raises ValueError
- count either returns 0 or 1 with ranges
- when using the list and tuple constructor on strings it breaks it up into chars

- Can use list comprehension to get around all elements needing to be strings with join:

~~~Python
>>> my_list = [1, 2, 3, 4]
>>> ', '.join([str(element) for element in my_list])
'1, 2, 3, 4'
~~~

### Dictionaries

- Dict's use key's and acan be of any hashable type
- values can be any type
- The dict.get method lets you bypass the KeyError when accessing a key that doesn't exist. By default, it returns None if the specified key doesn't exist. You can also pass it another value to use as the default value\
- Use `in` and `not in` to check for key membership

**In Python, an object is "hashable" if it has a stable and mostly unique identifier known as a hash value. This value, generated by the hash function, remains constant for the duration of an object's lifetime. Data structures like dictionaries and sets depend on this constancy for quick data retrieval. This is why retrievals from dictionaries are as fast as they are, but you don't need to know more right now.**

- Common hashable types: Integers and floats, strings, frozen sets, ranges, and tuples (if all elements are hashable)

### Sets

- Sets are designed to hold distinct objects, disregarding any sense of order. While they are mutable, the individual members must be hashable. In a sense, you can think of sets as dictionaries that have keys but no values. They even look a bit like dictionaries. However, they lack some of the functionality of dictionaries, so don't take that mental model too far.
- cannot use positional indexing
- sets are mutable but elements must be immutable
- Cannot add duplicate elements - won't raise error if you try
- can use remove() to remove elements, but if it isn't there it raises a KeyError, use discard() method to avoid this

### Frozen sets

- They are immutable
- Same properties as sets otherwise follow
- Since immutable, they are hashable, thus can be used as keys in dicts or members of a regular set
- the clear() method doesn't work here

### Conversion

- If you have a list of tuples, where each tuple is a pair (i.e., contains two objects), you can convert it to a dictionary:

~~~Python
>>> list_of_pairs = [('a', 1), ('b', 2), ('c', 3)]
>>> dict(list_of_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Can also use the zip function, it pairs up the corresponding elements of the input variables:

~~~Python
>>> keys = ['a', 'b', 'c']
>>> values = [1, 2, 3]
>>> zipped_pairs = zip(keys, values)
>>> dict(zipped_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Converting to a set will remove duplicates in the process
- You can also convert sets to frozen sets and vice versa

## Working with Strings and Ranges

### Ranges

- The `enumerate()` function uses tuple unpacking with for loops
- Notice that count always returns either 0 or 1. If the argument is present in the range, it returns 1. Otherwise, it returns 0. The count method is roughly equivalent to value in my_range. It differs only in the specific return values; in returns either True or False.

~~~Python
>>> my_range = range(3, 10)
>>> my_range.count(5)
1

>>> my_range.count(15)
0

>>> my_range.index(5)
2

>>> my_range.index(15)
ValueError: 15 is not in range
~~~

### Working with Strings

- str.index method searches a string for a specified substring and returns the index where the substring first appears. **If it doesn't locate the substring, it raises a ValueError**

- str.find also searches for substring, **if not found returns -1**
- str.count returns # of times substring in a string object
- All 3 accept optional arguments of start and end
- `str.replace(old, new, count) - if leave out optional count or -1 will replace all instances
- casefold() method better than lower for international strings with weird characters
- swapcase() is internationalized like casefold
- To use join method, elements must already be strings
- work around:

~~~Python
>>> numbers = [1, 2, 3, 4, 5]
>>> '-'.join([str(number) for number in numbers])
'1-2-3-4-5'
~~~

- the split function if you provide it `' '` it will split the string at all white spaces
- If try to split with empty string, raises ValueError
- If trying to split into individual chars, convert it into a list
- isalpha, isalnum, isdigit are all internationalized
- collections like lists, tuples, sets, frozen sets, and dicts can also be convertd to strings

## Working with Lists and Tuples

### Lists

- list.append adds object to end of list, list.insert inserts object prior to specific index position
- if index greater than list length, it inserts it at the end

~~~Python
>>> numbers = [1, 2, 3]
>>> numbers.append(4)
>>> numbers
[1, 2, 3, 4]

>>> numbers.insert(2, 'two-point-five')
>>> numbers
[1, 2, 'two-point-five', 3, 4]
~~~

- To insert another iterable, use list.extend
- remove() removes the first occurrence, pop() removes at specified index or last item in list
- list.reverse mutates the orignal list in place
- list.sort sorts the elements in place as well
list.sort is smart enough to deal with lists of strings and other types. As long as a < b is a valid expression for any two elements in the list, a and b, the method can sort the list. Thus, we can sort a list of strings as strings, even when they contain numeric values
- use sort(reverse=True) to perform a reverse sort
- can also do sort(key=str.casefold) to do case-insensitive sort
- also:

~~~Python
>>> numbers = ['61', '103', '525', '10100', '25', '3']
>>> numbers.sort(key=int)
>>> numbers
['3', '25', '61', '103', '525', '10100']
~~~

- You can pass sort any function or method that takes a single argument and returns a value as long as compatible with elements in the list

### Tuples

- Tuples unpacking: spreads out values from a tuples, assigning it to its respective variable in one clean sweep
- Unpacking works w/ all iterables but best with tuples b/c left and right need to match

### Merging Dictionaries

- With two dictionaries and wish to merge - use update. If keys in dictionary being updated overlap w/ keys in dict pased to update, their values get overwritten
- Python 3.9 introduced the merge (|) and update (|=) operators. The | operator combines two dictionaries in much the same was as does dict.update. However, instead of mutating one of the dictionaries, the merge operation returns a new dictionary. The |= operator does mutate one of the dictionaries; unlike most augmented assignment operators, it mutates rather than reassigns the object to the left of the operator

### Conversion to Dictionaries

- You can convert iterables containing key-value pairs into dicts

~~~Python
>>> list_data = [['name', 'Srdjan'], ['city', 'Belgrade']]
>>> dict_from_list = dict(list_data)
>>> dict_from_list
{'name': 'Srdjan', 'city': 'Belgrade'}

>>> tuple_data = (('name', 'Srdjan'), ('city', 'Belgrade'))
>>> dict_from_tuple = dict(tuple_data)
>>> dict_from_tuple
{'name': 'Srdjan', 'city': 'Belgrade'}
~~~

### Working with Sets

- sets are unordered collections of objects where every object is unique
- Ideal for situations where you want to avoid duplicates and don't care about the order of the objects
- subset: all elements of first set are in second set - `<= or issubset`
- superset: all elements of second set are in first set - `>= or issuperset`
- < and > check whether one subset or superset but not equal to other set
- union - combines two sets, collects all unique elements from both
    Use the union method or | operator: both don't mutate either set
- intersection - identifies common elements between two sets: use intersection method or & operator: don't mutate either set
- difference - determines what is in one set but not in another: use difference method or - operator: doesn't mutate either set
- isdisjoint - determines if no common elements aka intersection is empty

Methods

- add: adds single new member to existing set, if alrady exists won't do anyting
- remove: removes a single specified element from set, if isn't in set it raises a KeyError
- discard - if don't care whether element is in the set, use discard
- pop - removes and returns an arbitrary element from the set, raises KeyError if set is empty
- clear - discards all elements in a set, leaving empty set behind
**Converting a dictionary to a set only stores the dictionary keys in the new set***
**Frozen sets can be useful for dict keys when you need a set-like behavior for hashable objects**

## Unpacking Iterables

### Unary * Operator

- Serves as a tool that "unpacks" contents of an iterable:

~~~Python
>>> numbers = [1, 2, 3, 4]
>>> tup1 = (5, 6)
>>> tup2 = (7, 8)
>>> joined_list = [*numbers, *tup1, *tup2]
>>> joined_list
[1, 2, 3, 4, 5, 6, 7, 8]
~~~

- Can be used with lists, tuples, sets, even dicts (slight mod)
- can use to unpack arguments being passed to function:

~~~Python
def test(num1, num2, num3):
    # do something

numbers = [1, 2, 3]
test(numbers[0], numbers[1], numbers[2])
# now this:
test(*numbers)
~~~

- Python 3.8 came nested unpacking as well

~~~Python
numbers = [1, [2, 3, 4], 5]
a, (b, c, d), e = numbers
print(a, b, c, d, e)  # Outputs: 1 2 3 4 5
~~~

- use ** to unpack dictionaries - especially helpful in keyword arguments:

~~~Python
def profile(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

user_profile = {
    "name": "Srdjan",
    "age": 38,
    "profession": "software engineer",
}

profile(**user_profile)

# Output:
# name: Srdjan
# age: 38
# profession: software engineer
~~~

## PEDAC

- **P: understand the Problem**
  - Establish rules and define the boundaries of the problem
  - Restate the problem in your own words
  - Identify problem requirements:
    - Explicit
    - Implicit
  - Identify inputs and outputs
  - Ask questions / identify unclear information
- **E: examples / test cases**
  - Confirm or provide confirmation initial assumptions
  - Answer questions and provide implicit requirements
  - Can be run
  - Codify rules and boundaries of the problem
- **D: data structures**
  - Think in terms of data structures
  - Helps reason with data logically
  - Helps interact with data at the implementation stage
  - Closely linked to the algorithm used for your solution
- **A: algorithm**
  - Logical sequence of steps for accomplishing a task or objective
  - Closely related to data structures
  - At first, keep your algorithm abstract and high level
  - Break down stpes and fill in details as needed
  - Don't worry about efficiency at this stage
- **C: code**
  - Translating your solution algorithm into code
    - Think about our algorithm in the context of the programming language
      - Features and constraints
      - Characcteristics of data structures
      - Built in methods or functions
      - Syntax / general patterns
    - Create any test cases
  - Code with intent
**Don't think of PEDAC as linear**
- Move back and forth between steps
- Refer back to your notes
- Switch from implementation mode back to abstract problem solving mode when necessary
- Don't try to problem solve at the code level

~~~Python
"""
PROBLEM:

Given a string, write a function `palindrome_substrings` which returns
all the palindromic substrings of the string. Palindrome detection
should be case-sensitive.
"""

# Test cases:

# Comments show expected return values
palindrome_substrings("abcddcbA")   # ["bcddcb", "cddc", "dd"]
palindrome_substrings("palindrome") # []
palindrome_substrings("")           # []
palindrome_substrings("repaper")    # ['repaper', 'epape', 'pap']
palindrome_substrings("supercalifragilisticexpialidocious") # ["ili"]

def substrings(string):
    result = []
    start_index = 0

    while start_index <= len(string) - 2:
        num_chars = 2
        while num_chars <= len(string) - start_index:
            substring = string[start_index:start_index + num_chars]
            result.append(substring)
            num_chars += 1

        start_index += 1

    return result

def is_palindrome(string):
    reversed_string = string[::-1]
    if reversed_string == string:
        return True
    else:
        return False

def palindrome_substrings(s):
    result = []
    substrings_list = substrings(s)

    for substring in substrings_list:
        if is_palindrome(substring):
            result.append(substring)

    return result

print(palindrome_substrings("abcddcbA"))   # ["bcddcb", "cddc", "dd"]
print(palindrome_substrings("palindrome")) # []
print(palindrome_substrings(""))           # []
print(palindrome_substrings("repaper"))
# ['repaper', 'epape', 'pap']

print(palindrome_substrings("supercalifragilisticexpialidocious"))
# ["ili"]
~~~
