# PY110 Notes and Study Material

## Collections and Sequences

### Operations on Sequences

- Slicing: syntax for slicing is `sequence[start:stop:step]`
- stop index is not included in the slice
- If ommitted, start defaults to 0 for positive steps and -1 for negative step values

~~~Python
>>> lst = [0, 1, 2]

>>> # Omitting start with a positive step
>>> lst[::1]
[0, 1, 2]

>>> tup = (0, 1, 2)
>>> # Omitting start with a negative step
>>> tup[::-1]
(2, 1, 0)

>>> # For ranges, the start parameter works similarly:
>>> r = range(10)
>>> list(r[2:])
[2, 3, 4, 5, 6, 7, 8, 9]
~~~

- If stop index ommitted it will go up to the end of the sequence
- If start is greater than stop, the result is an empty sequence
- If step negative, empty sequence returned when stop is greater than start
- Note that my_list[::] is equivalent to my_list[:]. Both expressions yield a shallow copy of a list. This is considered pythonic or idiomatic code, so it's seen often.
- strings are sequences of characters so we iterate over them char by char:

~~~Python
>>> message = "bye"
>>> for char in message:
...    print(char)
...
b
y
e
~~~

- While loops are often used when you need the index of each item
- More idiomatic to use the enumerate function for this purpose

- You cannot concatenate ranges

- `sequence.count(value)` returns the number of occurrences of a value in the sequence
- `sequence.index(value)` returns the index of the first occurrence of a value in the sequence - if not present, raises ValueError
- count either returns 0 or 1 with ranges
- when using the list and tuple constructor on strings it breaks it up into chars

- Can use list comprehension to get around all elements needing to be strings with join:

~~~Python
>>> my_list = [1, 2, 3, 4]
>>> ', '.join([str(element) for element in my_list])
'1, 2, 3, 4'
~~~

### Dictionaries

- Dict's use key's and acan be of any hashable type
- values can be any type
- The dict.get method lets you bypass the KeyError when accessing a key that doesn't exist. By default, it returns None if the specified key doesn't exist. You can also pass it another value to use as the default value\
- Use `in` and `not in` to check for key membership

**In Python, an object is "hashable" if it has a stable and mostly unique identifier known as a hash value. This value, generated by the hash function, remains constant for the duration of an object's lifetime. Data structures like dictionaries and sets depend on this constancy for quick data retrieval. This is why retrievals from dictionaries are as fast as they are, but you don't need to know more right now.**

- Common hashable types: Integers and floats, strings, frozen sets, ranges, and tuples (if all elements are hashable)

### Sets

- Sets are designed to hold distinct objects, disregarding any sense of order. While they are mutable, the individual members must be hashable. In a sense, you can think of sets as dictionaries that have keys but no values. They even look a bit like dictionaries. However, they lack some of the functionality of dictionaries, so don't take that mental model too far.
- cannot use positional indexing
- sets are mutable but elements must be immutable
- Cannot add duplicate elements - won't raise error if you try
- can use remove() to remove elements, but if it isn't there it raises a KeyError, use discard() method to avoid this

### Frozen sets

- They are immutable
- Same properties as sets otherwise follow
- Since immutable, they are hashable, thus can be used as keys in dicts or members of a regular set
- the clear() method doesn't work here

### Conversion

- If you have a list of tuples, where each tuple is a pair (i.e., contains two objects), you can convert it to a dictionary:

~~~Python
>>> list_of_pairs = [('a', 1), ('b', 2), ('c', 3)]
>>> dict(list_of_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Can also use the zip function, it pairs up the corresponding elements of the input variables:

~~~Python
>>> keys = ['a', 'b', 'c']
>>> values = [1, 2, 3]
>>> zipped_pairs = zip(keys, values)
>>> dict(zipped_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Converting to a set will remove duplicates in the process
- You can also convert sets to frozen sets and vice versa

## Working with Strings and Ranges

### Ranges

- The `enumerate()` function uses tuple unpacking with for loops
- Notice that count always returns either 0 or 1. If the argument is present in the range, it returns 1. Otherwise, it returns 0. The count method is roughly equivalent to value in my_range. It differs only in the specific return values; in returns either True or False.

~~~Python
>>> my_range = range(3, 10)
>>> my_range.count(5)
1

>>> my_range.count(15)
0

>>> my_range.index(5)
2

>>> my_range.index(15)
ValueError: 15 is not in range
~~~

### Working with Strings

- str.index method searches a string for a specified substring and returns the index where the substring first appears. **If it doesn't locate the substring, it raises a ValueError**

- str.find also searches for substring, **if not found returns -1**
- str.count returns # of times substring in a string object
- All 3 accept optional arguments of start and end
- `str.replace(old, new, count) - if leave out optional count or -1 will replace all instances
- casefold() method better than lower for international strings with weird characters
- swapcase() is internationalized like casefold
- To use join method, elements must already be strings
- work around:

~~~Python
>>> numbers = [1, 2, 3, 4, 5]
>>> '-'.join([str(number) for number in numbers])
'1-2-3-4-5'
~~~

- the split function if you provide it `' '` it will split the string at all white spaces
- If try to split with empty string, raises ValueError
- If trying to split into individual chars, convert it into a list
- isalpha, isalnum, isdigit are all internationalized
- collections like lists, tuples, sets, frozen sets, and dicts can also be convertd to strings

## Working with Lists and Tuples

### Lists

- list.append adds object to end of list, list.insert inserts object prior to specific index position
- if index greater than list length, it inserts it at the end

~~~Python
>>> numbers = [1, 2, 3]
>>> numbers.append(4)
>>> numbers
[1, 2, 3, 4]

>>> numbers.insert(2, 'two-point-five')
>>> numbers
[1, 2, 'two-point-five', 3, 4]
~~~

- To insert another iterable, use list.extend
- remove() removes the first occurrence, pop() removes at specified index or last item in list
- list.reverse mutates the orignal list in place
- list.sort sorts the elements in place as well
list.sort is smart enough to deal with lists of strings and other types. As long as a < b is a valid expression for any two elements in the list, a and b, the method can sort the list. Thus, we can sort a list of strings as strings, even when they contain numeric values
- use sort(reverse=True) to perform a reverse sort
- can also do sort(key=str.casefold) to do case-insensitive sort
- also:

~~~Python
>>> numbers = ['61', '103', '525', '10100', '25', '3']
>>> numbers.sort(key=int)
>>> numbers
['3', '25', '61', '103', '525', '10100']
~~~

- You can pass sort any function or method that takes a single argument and returns a value as long as compatible with elements in the list

### Tuples

- Tuples unpacking: spreads out values from a tuples, assigning it to its respective variable in one clean sweep
- Unpacking works w/ all iterables but best with tuples b/c left and right need to match

### Merging Dictionaries

- With two dictionaries and wish to merge - use update. If keys in dictionary being updated overlap w/ keys in dict pased to update, their values get overwritten
- Python 3.9 introduced the merge (|) and update (|=) operators. The | operator combines two dictionaries in much the same was as does dict.update. However, instead of mutating one of the dictionaries, the merge operation returns a new dictionary. The |= operator does mutate one of the dictionaries; unlike most augmented assignment operators, it mutates rather than reassigns the object to the left of the operator

### Conversion to Dictionaries

- You can convert iterables containing key-value pairs into dicts

~~~Python
>>> list_data = [['name', 'Srdjan'], ['city', 'Belgrade']]
>>> dict_from_list = dict(list_data)
>>> dict_from_list
{'name': 'Srdjan', 'city': 'Belgrade'}

>>> tuple_data = (('name', 'Srdjan'), ('city', 'Belgrade'))
>>> dict_from_tuple = dict(tuple_data)
>>> dict_from_tuple
{'name': 'Srdjan', 'city': 'Belgrade'}
~~~

### Working with Sets

- sets are unordered collections of objects where every object is unique
- Ideal for situations where you want to avoid duplicates and don't care about the order of the objects
- subset: all elements of first set are in second set - `<= or issubset`
- superset: all elements of second set are in first set - `>= or issuperset`
- < and > check whether one subset or superset but not equal to other set
- union - combines two sets, collects all unique elements from both
    Use the union method or | operator: both don't mutate either set
- intersection - identifies common elements between two sets: use intersection method or & operator: don't mutate either set
- difference - determines what is in one set but not in another: use difference method or - operator: doesn't mutate either set
- isdisjoint - determines if no common elements aka intersection is empty

Methods

- add: adds single new member to existing set, if alrady exists won't do anyting
- remove: removes a single specified element from set, if isn't in set it raises a KeyError
- discard - if don't care whether element is in the set, use discard
- pop - removes and returns an arbitrary element from the set, raises KeyError if set is empty
- clear - discards all elements in a set, leaving empty set behind
**Converting a dictionary to a set only stores the dictionary keys in the new set***
**Frozen sets can be useful for dict keys when you need a set-like behavior for hashable objects**

## Unpacking Iterables

### Unary * Operator

- Serves as a tool that "unpacks" contents of an iterable:

~~~Python
>>> numbers = [1, 2, 3, 4]
>>> tup1 = (5, 6)
>>> tup2 = (7, 8)
>>> joined_list = [*numbers, *tup1, *tup2]
>>> joined_list
[1, 2, 3, 4, 5, 6, 7, 8]
~~~

- Can be used with lists, tuples, sets, even dicts (slight mod)
- can use to unpack arguments being passed to function:

~~~Python
def test(num1, num2, num3):
    # do something

numbers = [1, 2, 3]
test(numbers[0], numbers[1], numbers[2])
# now this:
test(*numbers)
~~~

- Python 3.8 came nested unpacking as well

~~~Python
numbers = [1, [2, 3, 4], 5]
a, (b, c, d), e = numbers
print(a, b, c, d, e)  # Outputs: 1 2 3 4 5
~~~

- use ** to unpack dictionaries - especially helpful in keyword arguments:

~~~Python
def profile(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

user_profile = {
    "name": "Srdjan",
    "age": 38,
    "profession": "software engineer",
}

profile(**user_profile)

# Output:
# name: Srdjan
# age: 38
# profession: software engineer
~~~

## PEDAC

- **P: understand the Problem**
  - Establish rules and define the boundaries of the problem
  - Restate the problem in your own words
  - Identify problem requirements:
    - Explicit
    - Implicit
  - Identify inputs and outputs
  - Ask questions / identify unclear information
- **E: examples / test cases**
  - Confirm or provide confirmation initial assumptions
  - Answer questions and provide implicit requirements
  - Can be run
  - Codify rules and boundaries of the problem
- **D: data structures**
  - Think in terms of data structures
  - Helps reason with data logically
  - Helps interact with data at the implementation stage
  - Closely linked to the algorithm used for your solution
- **A: algorithm**
  - Logical sequence of steps for accomplishing a task or objective
  - Closely related to data structures
  - At first, keep your algorithm abstract and high level
  - Break down stpes and fill in details as needed
  - Don't worry about efficiency at this stage
- **C: code**
  - Translating your solution algorithm into code
    - Think about our algorithm in the context of the programming language
      - Features and constraints
      - Characcteristics of data structures
      - Built in methods or functions
      - Syntax / general patterns
    - Create any test cases
  - Code with intent
**Don't think of PEDAC as linear**
- Move back and forth between steps
- Refer back to your notes
- Switch from implementation mode back to abstract problem solving mode when necessary
- Don't try to problem solve at the code level

~~~Python
"""
PROBLEM:

Given a string, write a function `palindrome_substrings` which returns
all the palindromic substrings of the string. Palindrome detection
should be case-sensitive.
"""

# Test cases:

# Comments show expected return values
palindrome_substrings("abcddcbA")   # ["bcddcb", "cddc", "dd"]
palindrome_substrings("palindrome") # []
palindrome_substrings("")           # []
palindrome_substrings("repaper")    # ['repaper', 'epape', 'pap']
palindrome_substrings("supercalifragilisticexpialidocious") # ["ili"]

def substrings(string):
    result = []
    start_index = 0

    while start_index <= len(string) - 2:
        num_chars = 2
        while num_chars <= len(string) - start_index:
            substring = string[start_index:start_index + num_chars]
            result.append(substring)
            num_chars += 1

        start_index += 1

    return result

def is_palindrome(string):
    reversed_string = string[::-1]
    if reversed_string == string:
        return True
    else:
        return False

def palindrome_substrings(s):
    result = []
    substrings_list = substrings(s)

    for substring in substrings_list:
        if is_palindrome(substring):
            result.append(substring)

    return result

print(palindrome_substrings("abcddcbA"))   # ["bcddcb", "cddc", "dd"]
print(palindrome_substrings("palindrome")) # []
print(palindrome_substrings(""))           # []
print(palindrome_substrings("repaper"))
# ['repaper', 'epape', 'pap']

print(palindrome_substrings("supercalifragilisticexpialidocious"))
# ["ili"]
~~~

## Sorting

### Custom Sorting

- First class values / first class objects
  - Can be assigned to a variable or an element of a data structure
  - Can be passed as an argument to a function
  - Can be returned as the return value of a function
  - Ex: all data types and user defined classes
  - Functions are also considered 'first class functions'
- **Functions that accept function arguments or that return functions are known as higher order functions**
- `sorted(), list.sort` are both higher-order functions
- Can use tuple unpacking for custom sorting:

~~~Python
def person_key(person):
    name, age = person
    return (age, name)

people = [("Jack", 30), ("John", 25), ("Betty", 25), ("Anna", 30)]
sorted_people = sorted(people, key=person_key)
print(sorted_people)
# [('Betty', 25), ('John', 25), ('Anna', 30), ('Jack', 30)]
~~~

## PY119 TA session on 06/30

AGENDA - ASSESSMENT PREP

- Introductions
- Overview of Assessment format:
  => Written Assessment
  - 1hr 45min time limit
  - Around 11 questions
  - Use Markdown
  - Clear, detailed, and precise answers
  - Time management
  => Interview Assessment
    - 1 hour / 2 problems
    - Focus: structured problem solving, Python fluency, and communication ability
    - No documentation
    - Be sure to complete PEDA before moving on to C
    - Test code early and often
    - Communicate! (and not just what you are typing)
- Study Tips for Assessments:
  => Practice problems
  => Study with other students
  - Try Gather.town (via #the-spot on Slack)
- Questions?
- Practice
- Wrap up & feedback form

## PY119 Study Guide Topics

In general, you should be familiar with Python syntax and operators.
You should also be able to clearly explain, talk about, or demonstrate the following topics:

### str methods

- str.index(sub[, start[, end]]) - like find() but raises a *ValueError* when substring is not found.
- str.find(sub[, start[, end]]) - return lowest index in the string where substring sub is found w/in the slide s[start:end]. Optional arguments start and end are interpreted in slice notation
  - returns -1 if sub is not found
- str.split(sep=None, maxsplit=-1) - return a list of the words in the string, using sep as the delimiter string. 
  - If *maxsplit* given, at most maxsplit splits are done (at most maxsplit +1 elements). If maxspit not specified or -1, then there is no limit on number of splits (all possible are made)
  - If *sep* is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings
  - If *sep* not specified or is None: runs of consecutive whitespace are regarded a single seperator and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace

~~~Python
'1,2,3'.split(',')
['1', '2', '3']
'1,2,3'.split(',', maxsplit=1)
['1', '2,3']
'1,2,,3,'.split(',')
['1', '2', '', '3', '']
~~~

~~~Python
'1 2 3'.split()
['1', '2', '3']
'1 2 3'.split(maxsplit=1)
['1', '2 3']
'   1   2   3   '.split()
['1', '2', '3']
~~~

- str.strip([chars]) - return a copy of the string with the leading and trailing characters removed. *Chars* arg is a string specifying the set of characters to be removed. If ommitted or None, the *chars* arg defaults to removing whitespace. 
  - *Chars* arg is not a prefix or suffic, rather, all combinations of its values are stripped

~~~Python
'   spacious   '.strip()
'spacious'
'www.example.com'.strip('cmowz.')
'example'
~~~

- str.join(iterable) - return a string which is the concatenation of the strings in *iterable*.
  - TypeError raised if there are any non-string values in *iterable*, including bytes objects.
  - str. is the seperator between elements
- str.replace(old, new[, count]) -return a copy of the string with all occurrences of substring *old* replaced by *new*. If optional argument *count* is given, only the first *count* occurrences are replaced
- str.upper() - return a copy of the string with all cased characters coverted to uppercase.
  - remember str.upper().isupper() might be false
- str.lower() - return a copy of the string with all cased characters converted to lowercase.
- str.capitalize() - return a copy of the string with its first character capitalized and the rest lowercased.

### list methods (mutable sequence common methods)

- list.append(x) - appends to the end of the sequence
  - same as s[len(s):len(s)] = [x]

- list.extend(iterable) - extend the ist by appending all items from the iterable.
  - Equivalentn to a[len(a):] = iterable

- list.insert(i, x) - insert an item at a given position.
  - First argument is the index of the element before which to insert, so `a.insert(0,x)` inserts at the front of the list, and `a.insert(len(a), x)` is equivalent to `a.append(x)`.

- list.remove(x) - remove first item from list whose value is equal to x.
  - raises a ValueError if there is no such item

- list.pop([i]) - remove item at given position in the list **and return it**
  - If no index specified, removes and returns the last item in the lsit
  - Raises an IndexError if list is empty or index is outside the list range

- list.clear() - remove all items from the list
  - equivalent to del a[:].

- list.index(x[, start[, end]]) - return zero-based index in the list of the first item whose value is equal to *x*.
  - Raises a ValueError if there is no such item
  - optional arguments are interpreted as in the slice notation are used to limit the search to a particular subsequence of the list. **The returned index is computed relative to the beginning of the full sequence rather than the *start* argument**
  - test out slice uses

- list.count(x) - return the number of times x appears in a list

- list.sort(*, key=None, reverse=False) - sort the items of the list in place
  - custom arguments folow same pattern as sorted() function
  - uses only the < comparions between items - exceptions are not suppressed - if any comparison operation fails, the entire sort op fails and list will likely be left in a partially modified state
  - must pass args as keywords
  - *key* specified a function of one argument that is used to extract a comparison key from each list element. The key corresponding to each item in the list is calculated once and then used for the entire sorting process. Default of None means that list items are sorted directly without calculating a seperate key value.
  - If reverse set to True, list elements are sorted as if each comparison were reversed - operates by side effect, does not return the sorted sequence.
  - Is stable, does not change relative order of elements that compare equal

- list.reverse() - reverse the elements of the list in place

- list.copy() - return a shallow copy of the list
  - equivalent to a[:] (slice notation for copy of whole array).

- ***Not on official study guide** - use zip() to loop over two or more sequences at the same time

~~~Python
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print('What is your {0}?  It is {1}.'.format(q, a))

# What is your name?  It is lancelot.
# What is your quest?  It is the holy grail.
# What is your favorite color?  It is blue.
~~~

### dict methods

- keys() - return a new view of the dictionary's keys.
  - keys views are set like since their entries are unique and hashable
- values() - return a new view of the dictionary's values.
  - equality comparison between one dict.values() and another will always reutrn false.
- items() - return new view of the dictionary's items (key, value) pairs.
  - set like since pairs are unique and keys are hashable. If all values in an items view are hashable as well,then items view can interoperate with other sets
- get(key, default=None) - return the value for *key* if *key* is in the dictionary, else *default*. If *default* is not given, it defaults to None so that this method never raises a KeyError.
- setdefault(key, default=None) - If *key* is in the dictionary, return its value. If not, insert *key* with a value of *defualt* and return *default*. *Default* is None.
- update([other]) - update the dictionary with the key/value pairs from *other*, overwriting existing keys. Return None.
  - accepts either another dictioary object or an iterable of key/value pairs (as tuples or other iterables of length two).
  - If keyword arguments specified, the dictionary then updated with those key/value pairs: `d.update(red=1, blue=2)`.
- pop(key[, default]) - If *key* is in the dictionary, remove it and return its value, else return default.
  - If *default* is not given and *key* is not in the dictionary, a KeyError is raised.
- popitem() - remove and return a (key, value) pair from the dictionary
  - Pairs are returned in LIFO order
  - If empty, raises a KeyError
- clear() - removes all items from the dictionary

### set methods

- **The output of the list.sort() method is undefined for a list of sets**
- **Instances of set are comopared to instances of frozenset based on their members** `set('abc') == frozenset('abc')` returns True.
- add(elem) - add element to the set.

- update(*others) - update the set, adding elements from all others
  - equivalent to `set |= other |...`

- remove(elem) - remove element *elem* from the set, 
  - Raises a keyError if *elem* is not contained in the set.

- clear() - remove all elements from the set

- union(*others) - return a new set with elements from the set and all others.
  - equivalent to `set | other |...`

- intersection(*others) - return a new set with elements common to the set and all others.
  - equivalent to `set & other & ...`

- difference(*others) - return a new set with elements in the set that are not in the others
  - equivalent to `set - other - ...`

- issubset(other) - test whether every element in the set is in the other
  - equivalent to `set <= other`

- issuperset(other) - test whether every element in other is in the set
  - equivalent to `set >= other`
  - just `>` tests for *proper* super set. Meanining set also != other.

- isdisjoint(other) - return true if the set has no elements in common with other.
  - Sets are disjoint if and only if their intersection is the empty set.
  - & operator for intersection

### frozenset methods

- union - same as set
- intersection - same as set
- difference - same as set
- issubset - same as set
- issuperset - same as set
- isdisjoint - same as set

### tuple methods

- count(x) - total number of occurrences of x in s
  - returns 0 if there are no occurrences
- index(x[, i[, j]]) - index of the first occurrence of x in s (at or after indiex i and before index j)
- unpacking - used to assign variables values from a tuple
  - Ex: a, b, c = tuple([1, 2, 3])

### range and enumerate

Understanding of how to create and use range objects and enumerate for indexing during iteration.

- Yes, I know how to do this.

### The built-in functions sum and all

- sum(iterable, /, start=0) - sums start and the items of an iterable from left to right and returns the total. The *iterable's* items are normally numbers, and the start value is not allowed to be a string.

### Conditional statements (if, elif, else)

- Yes, I know this.

### Iteration using for loops, break, continue

- Break is used to get out of the current loop
- Continue is used to skip the remaining code inside the looop for the current iteration only

### sorting lists using the sorted function and list.sort method

- list.sort description above
- sorted(iterable, /, *, key=None, reverse=False)
  - returns a new sorted list from the items in *iterable*
  - two optional args that must be keywords: key and reverse
  - guaranteed to be stable

### Custom sorting using the key parameter and reverse sorting using the reverse parameter

- reviewed above

### Comprehensions

- Yes, I know this

### nested data structures and nested iteration

### shallow and deep copy

### see article for better slice notation examples

- <https://stackoverflow.com/questions/509211/how-slicing-in-python-works>

## *args and **kwars

- Using the *, the variable that we associate with the '*' becomes iterable - meaning you can do things like iterate over it, run some higher-order functions such as map and filter etc.
- **kwargs receives arguments as a dictionary, so you can iterate over the pairs.
