# PY110 Notes and Study Material

## Collections and Sequences

### Operations on Sequences

- Slicing: syntax for slicing is `sequence[start:stop:step]`
- stop index is not included in the slice
- If ommitted, start defaults to 0 for positive steps and -1 for negative step values

~~~Python
>>> lst = [0, 1, 2]

>>> # Omitting start with a positive step
>>> lst[::1]
[0, 1, 2]

>>> tup = (0, 1, 2)
>>> # Omitting start with a negative step
>>> tup[::-1]
(2, 1, 0)

>>> # For ranges, the start parameter works similarly:
>>> r = range(10)
>>> list(r[2:])
[2, 3, 4, 5, 6, 7, 8, 9]
~~~

- If stop index ommitted it will go up to the end of the sequence
- If start is greater than stop, the result is an empty sequence
- If step negative, empty sequence returned when stop is greater than start
- Note that my_list[::] is equivalent to my_list[:]. Both expressions yield a shallow copy of a list. This is considered pythonic or idiomatic code, so it's seen often.
- strings are sequences of characters so we iterate over them char by char:

~~~Python
>>> message = "bye"
>>> for char in message:
...    print(char)
...
b
y
e
~~~

- While loops are often used when you need the index of each item
- More idiomatic to use the enumerate function for this purpose

- You cannot concatenate ranges

- `sequence.count(value)` returns the number of occurrences of a value in the sequence
- `sequence.index(value)` returns the index of the first occurrence of a value in the sequence - if not present, raises ValueError
- count either returns 0 or 1 with ranges
- when using the list and tuple constructor on strings it breaks it up into chars

- Can use list comprehension to get around all elements needing to be strings with join:

~~~Python
>>> my_list = [1, 2, 3, 4]
>>> ', '.join([str(element) for element in my_list])
'1, 2, 3, 4'
~~~

### Dictionaries

- Dict's use key's and acan be of any hashable type
- values can be any type
- The dict.get method lets you bypass the KeyError when accessing a key that doesn't exist. By default, it returns None if the specified key doesn't exist. You can also pass it another value to use as the default value\
- Use `in` and `not in` to check for key membership

**In Python, an object is "hashable" if it has a stable and mostly unique identifier known as a hash value. This value, generated by the hash function, remains constant for the duration of an object's lifetime. Data structures like dictionaries and sets depend on this constancy for quick data retrieval. This is why retrievals from dictionaries are as fast as they are, but you don't need to know more right now.**

- Common hashable types: Integers and floats, strings, frozen sets, ranges, and tuples (if all elements are hashable)

### Sets

- Sets are designed to hold distinct objects, disregarding any sense of order. While they are mutable, the individual members must be hashable. In a sense, you can think of sets as dictionaries that have keys but no values. They even look a bit like dictionaries. However, they lack some of the functionality of dictionaries, so don't take that mental model too far.
- cannot use positional indexing
- sets are mutable but elements must be immutable
- Cannot add duplicate elements - won't raise error if you try
- can use remove() to remove elements, but if it isn't there it raises a KeyError, use discard() method to avoid this

### Frozen sets

- They are immutable
- Same properties as sets otherwise follow
- Since immutable, they are hashable, thus can be used as keys in dicts or members of a regular set
- the clear() method doesn't work here

### Conversion

- If you have a list of tuples, where each tuple is a pair (i.e., contains two objects), you can convert it to a dictionary:

~~~Python
>>> list_of_pairs = [('a', 1), ('b', 2), ('c', 3)]
>>> dict(list_of_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Can also use the zip function, it pairs up the corresponding elements of the input variables:

~~~Python
>>> keys = ['a', 'b', 'c']
>>> values = [1, 2, 3]
>>> zipped_pairs = zip(keys, values)
>>> dict(zipped_pairs)
{'a': 1, 'b': 2, 'c': 3}
~~~

- Converting to a set will remove duplicates in the process
- You can also convert sets to frozen sets and vice versa

## Working with Strings and Ranges

### Ranges
