# Practice PY139 test with questions generated by Robby Feconda

- First-Class and Higher-Order Functions
  1. What is the difference between First-Class and Higher-Order Functions? What about First-Class citizens?
  First-Class objects are a description of how objects are treated in Python. First-Class citizens is another name for the same concept.
  First-Class objects are objects that are able to be assigned to variables (*or stored in another object*) and passed around via function calls(*Passed as an argument and return value of a function*). In Python, all objects are First-Class objects. This also includes functions.
  Higher-Order functions are a more specific kind of First-Class object in that they are functions that expect to receive another function as an argument and (*NOT and it's OR*) return a function.

  2. What attributes do Higher-Order Functions have that make them unique? Include what callbacks are.
  They expect to receive a function(s) as an argument *or* return a function. *If said function intends to invoke the passed function that is called a callback. If it does not ever invoke the function given as an argument, then it is not considered a callback*

  3. Explain the concept of functions and methods as First-Class Objects and use a code example to demonstrate it.

  ~~~Python
  lst = ['a', 'bb', 'ccccc', 'dd']
  new_lst = sorted(lst, key=len)
  ~~~

  The above code example with the sorted function shows the concept of functions being treated as first-class objects.
  Here we see that we are able to pass the len() function as an argument to the key parameter to be used in the sorted() function.

  4. What is the difference between imperitive and declarative programming? Use a code example with a transformation or selection function to explain.
  Imperitive versus declarative programming are two programming paradigms that guage the level of abstraction that a program uses. In imperitive programming, the programmer tells the computer what to do every step of the way. An example of this can be shown with string manipulation.
  In the below example, with imperitive style programming, we can iterate through the list of strings and tell the computer what to do each time.

  ~~~Python
  # imperitive
  lst = ['one', 'two', 'three']
  new_lst = []
  for item in lst:
      new_lst.append(item.title())

  # declarative
  new_lst = map(title, lst)
  ~~~

  However, following a declarative style we can tell the computer what we want to accomplish rather than telling it what to do at each step. This can be shown accomplishing the same string manipulation but instead of using a for loop using the map() function.

  5. What does using declaritive programming techniques with higher-order functions allow us to accomplish in Python with regards to OO design principles? think for_each
  The declarative style of programming as shown in the previous code example allows us to reach higher level of abstractions. With regards to object-oriented design, it allows us to work with generics more easily by designing functions and methods that encapsulate the more imperitive level of programming.

  6. Provide a code example of a factory function and what they are useful for.

  ~~~Python
  # Factory function example
    def greeter(prompt):
        def add_greet(str_input):
            return prompt + str_input
        return add_greet

    name = 'Robby'

    say_hello = greeter('Howdy')
    print(say_hello(name))
    ~~~

    The above geeter() function shows the application of a function factory. A function factory is designed to create and return specialized functions that are to be used elsewhere in a program. 
    This allows the programmer to encapsulate logic that might otherwise be repeated and use it at various points in their program. Overall, this enables DRY code. *The above example is also an example of partial function application, which factory functions are a subset of, implemented with closure*

  7. How do callables fit into functions and classes?
  Callables in Python are anything that can be executed. That is, anything that can be "called" using the `name_of_method()` syntax. While this obviously applies to functions and class methods, this also applies to Classes themselves as well. 
  This can be seen by accessing the `__call__` method in the Class. This property is also able to be customized when defining custom Classes for specific behavior. *The ability to call functions and classes is intrinsically present already*

- Generator Expressions
  1. What is a generator? Is it an iterable?
  2. What is a generator expression?
  3. Talk about single use with regards to generators. Give a code example.
  4. Can you determine the length of a generator?
  5. Provide a code example of a generator code function. What does the yield keyword do? explain each line of the function.
  6. Explain the next() function with a code example.
  7. Explain the use cases of generators

- Lambda functions
  1. Provide a code example of a lambda function utilizing iterable unpacking
  2. What are the restrictions and cons of lambda functions?

- File Handling
  1. How does the open() function work? What modes are available?
  2. Explain the various methods for reading a files contents. What are the shortfalls and advantages of them.
  3. How do you write to a file? Difference between write and append?
  4. Discuss closing a file and how to minimize this issue by using the with statement
  5. What is a good practice with regards to error handling and files?

- Function arguments and parameters: positional, keyword, positional-only, keyword-only, *args, **kwargs, default params
  1. Provide code examples to illustrate how you can specifically define what kind of arguments a function takes
  2. How can you capture multiple positional and multiple keyword arguments? Describe the asterisk operator in this.
  3. Describe the asterisk operator with regards to iterable unpacking. How does it relate to iterables? Is there a limit to unpacking objects?
  4. Provide a code exampel of extended unpacking. What are the limitations? What about with dictionaries?
  5. What is the difference when using the asterisk operator to unpack vs in a function call? When is a list created and not a tuple?

- Closures
  1. What is the definition of a closure?
  2. How do the scope rules of Python apply to creating closures?
  3. What object is created to manage the free variables within a functions scope? How can you access them?
  4. Provide a code example demonstrating late binding.

- Partial function application
  1. What are the two ways in which partial function application is done in Python?
  2. Provide a code example of partial function application utilizing closure and explain each step of the function execution.
  3. What is the difference between a factory function and a partial function? Provide a code example.

~~~Python
def curry(fn, *cargs, **ckwargs):
    def call_fn(*fargs, **fkwargs):
        d = ckwargs.copy()
        d.update(fkwargs)
        return fn(*(cargs + fargs), **d)
    return call_fn
~~~

- Source: <https://peps.python.org/pep-0309/>

1. Explain the above code example with regards to partial function application and closures

- Decorators
  1. What is the definition of a decorator? What are their purpose?
  2. Discuss the advantages that decorators can provide? Discuss the study of is_prime and lru_cache.
  3. Can decorators be used with only functions? Discuss the differing behavior.
  4. Provide a code example describing the execution behavior of stacked decorators. How does the wrapping differ in defined functions?

- Modules
  1. What is a module object?
  2. How does the from keyword work with regards to imports?
  3. What global variable within modules defines its behavior? What is the difference between a script and a module?
  4. Discuss naming conflicts with regards to imports. What about wildcard imports and namespace pollution?

- Pure functions and side effects
  1. What actions are said to be a side effect? provide a code example for each.
  2. Discuss a major source of bugs in programs and how it related to side effects.
  3. What is the definition of a pure function? Where does lifetime come into play?
  4. Review practice problems on course module.

- Testing terminology
  1. Define the following: test suite, test, assertion

- Writing and running tests with unittest framework
  1. Provide a code example for setting up a basic unit test and describe each of the steps.
  2. What are the various outputs you can receive when running tests?

- Utilizing assertions for testing equality and other conditions: `assertEqual`, `assertIs` etc.
  1. Provide code example of the common assertions available.
  2. What are the two different ways to utilize errors in assertions? How is the with keyword used?
  3. Give code examples of testing equality vs testing values. Why is defining `__eq__` important?

- SEAT appraoch
  1. Define and describe SEAT

- Understanding code coverage
  1. What program is used to get code coverage?
  2. What is code coverage useful for with regards to testing?

- Project directory layout
- Using `pip` for package installation and management
- packaging projects
  1. Describe the layout of what a project looks like and the steps taken to package it. How do you then deliver it to PyPi?
