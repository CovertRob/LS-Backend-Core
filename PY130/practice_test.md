# Practice PY139 test with questions generated by Robby Feconda

- Post-edits are *italicized*

- First-Class and Higher-Order Functions
  1. What is the difference between First-Class and Higher-Order Functions? What about First-Class citizens?
  First-Class objects are a description of how objects are treated in Python. First-Class citizens is another name for the same concept.
  First-Class objects are objects that are able to be assigned to variables (*or stored in another object*) and passed around via function calls(*Passed as an argument and return value of a function*). In Python, all objects are First-Class objects. This also includes functions.
  Higher-Order functions are a more specific kind of First-Class object in that they are functions that expect to receive another function as an argument and (*NOT and it's OR*) return a function.

  2. What attributes do Higher-Order Functions have that make them unique? Include what callbacks are.
  They expect to receive a function(s) as an argument *or* return a function. *If said function intends to invoke the passed function that is called a callback. If it does not ever invoke the function given as an argument, then it is not considered a callback*

  3. Explain the concept of functions and methods as First-Class Objects and use a code example to demonstrate it.

  ~~~Python
  lst = ['a', 'bb', 'ccccc', 'dd']
  new_lst = sorted(lst, key=len)
  ~~~

  The above code example with the sorted function shows the concept of functions being treated as first-class objects.
  Here we see that we are able to pass the len() function as an argument to the key parameter to be used in the sorted() function.

  4. What is the difference between imperitive and declarative programming? Use a code example with a transformation or selection function to explain.
  Imperitive versus declarative programming are two programming paradigms that guage the level of abstraction that a program uses. In imperitive programming, the programmer tells the computer what to do every step of the way. An example of this can be shown with string manipulation.
  In the below example, with imperitive style programming, we can iterate through the list of strings and tell the computer what to do each time.

  ~~~Python
  # imperitive
  lst = ['one', 'two', 'three']
  new_lst = []
  for item in lst:
      new_lst.append(item.title())

  # declarative
  new_lst = map(title, lst)
  ~~~

  However, following a declarative style we can tell the computer what we want to accomplish rather than telling it what to do at each step. This can be shown accomplishing the same string manipulation but instead of using a for loop using the map() function.

  5. What does using declaritive programming techniques with higher-order functions allow us to accomplish in Python with regards to OO design principles? think for_each
  The declarative style of programming as shown in the previous code example allows us to reach higher level of abstractions. With regards to object-oriented design, it allows us to work with generics more easily by designing functions and methods that encapsulate the more imperitive level of programming.

  6. Provide a code example of a factory function and what they are useful for.

  ~~~Python
  # Factory function example
    def greeter(prompt):
        def add_greet(str_input):
            return prompt + str_input
        return add_greet

    name = 'Robby'

    say_hello = greeter('Howdy')
    print(say_hello(name))
    ~~~

    The above geeter() function shows the application of a function factory. A function factory is designed to create and return specialized functions that are to be used elsewhere in a program. 
    This allows the programmer to encapsulate logic that might otherwise be repeated and use it at various points in their program. Overall, this enables DRY code. *The above example is also an example of partial function application, which factory functions are a subset of, implemented with closure*

  7. How do callables fit into functions and classes?
  Callables in Python are anything that can be executed. That is, anything that can be "called" using the `name_of_method()` syntax. While this obviously applies to functions and class methods, this also applies to Classes themselves as well. 
  This can be seen by accessing the `__call__` method in the Class. This property is also able to be customized when defining custom Classes for specific behavior. *The ability to call functions and classes is intrinsically present already*

- Generator Expressions
  1. What is a generator? Is it an iterable?
  A generator is a type of iterable object that provides values by request (*a series of values on demand*). Each time a value is requested from the generator, it returns only the next value in the iterable. Generators are one time use objects for the length of the program execution.

  2. What is a generator expression?
  A generator expression is similar to a list comprehension except it is with parentheses. The syntax is as follows: `gen = (i for i in range(10))`. In the provided code example, you can iterate over the gen variable because it is a generator object.

  3. Talk about single use with regards to generators. Give a code example.
  Given the previous code example, if you iterate over the entirety of the range in the generator expression that defines the generator object for the variable gen, you will not be able to iterate over it again. If you try to you will receive a StopIteration exception. (*This single-use iterable trait also applies when they are passed to iterative functions like list, tuple, and set*)

  4. Can you determine the length of a generator?
  A generators length is not able to be determined since the only value known to the generator at any given time is the next value in the iterable when requested.
  Generators are commonly used for data intensive operations since they are designed to not story the entirety of what it is iterating over in memory all at once. This is why the length is not able to be determined.

  5. Provide a code example of a generator code function. What does the yield keyword do? explain each line of the function.
  
  ~~~Python
  from string import ascii_uppercase

    def gen_example():
        for letter in ascii_uppercase:
            yield letter

    print(next(gen_example()))
    ~~~

    The above code example utilizes a generator function to print uppercased alphabet characters. Currently, it only prints the letter 'A'. In the body of the generator function we have the yield keyword. (*The execution of the function is paused and will resume at the `yield` keyword.*)
    What this keyword does is it returns a value like the `return` keyword does, but instead of terminating the function execution it pauses it. This is shown when we call `next(gen_example())` and print the value.
    It only prints the letter 'A' because that is the first value in the generator and it pauses execution after yielding that value. If we were to call `next()` on the generator again, it would print 'B'.
    (*When the generator function is called the function is not executied. Since it contains `yield` in the definition body it returns a generator object.*)

  6. Explain the next() function with a code example.
  The `next()` function allows us to access the next value in the generator object. At each call of `next()`, the generator will produce the next value. This allows us to access one value at a time and not exhaust the entire generator all at once.

  7. Explain the use cases of generators
  Explained above in the length question.
  (*Also: integrating with functions such as `sum(), min(), all(), any()` and others that work with iterators*)

- Lambda functions
  1. Provide a code example of a lambda function with iterable unpacking

  ~~~Python
    names = ['jasmin ', 'robby ', 'heather']

    capitalize = lambda name1, name2, name3: name1.title() + name2.title() + name3.title()

    print(capitalize(*names)) # Jasmin Robby Heather
  ~~~

  2. What are the restrictions and cons of lambda functions?
  Restrictions: they do not allow assignments (*or loops, if statements, or any other statements*), no return statements are allowed, only one expression is allowed, (*no docstrings*), (*can be difficult to debug since they don't have names*), *(don't permit `*args or **kwargs`*)

- File Handling
  1. How does the open() function work? What modes are available?
  The open() function works by taking the file path to a file as an argument and returns a file object that allows us to perform operations on said file. The`open()` function has read, write, and append as the primary modes. Note that the file path will default to the current working directory if no path is provided to the file name.
  (*Files include program files, images, spreadsheets, word processor documents, commands for the command line, applications*)

  2. Explain the various methods for reading a files contents. What are the shortfalls and advantages of them.
  There are three primary ways for reading data from a file object. They are `read(), readlines(), and readline()`.
  Read will read in the entirety of the file. This can be dangerous due to memory constraints if it is a large file. 
  Readlines will also read in the entirety of the file but will do so one line at a time. It returns a list of strings, one for each input line.
  Readline will read in one line at at time for each invocation.
  3. How do you write to a file? Difference between write and append?
  To write to a file you will need to open the file in the write mode with the `open()` function and then use the `write()` or `writelines()` methods to write to the file. The below code example shows how.

  ~~~Python
  file = open('output.txt', 'w')
  file.write('Hello, world\n')

  lines ['test1\n', 'test2\n']
  file.writelines(lines)

  file.close()
  ~~~

  When using append mode the write functions will add it onto the end of the file.

  4. Discuss closing a file and how to minimize this issue by using the with statement
  It's important to close a file once you are done working with it so you free up any system resources associated with it.
  Use the `file_object.close()` syntax to do this. The below code example shows closing a file using the `with` statement. 
  It is imortant to use the with statement because after the block of code scoped by the `with` keyword is done executing it automatically closes the file.
  (*This is known as a context managert*)

  5. What is a good practice with regards to error handling and files?
  The `with` keyword concept described above closes the file even if an exception occurs.
  To handle errors when opening a file use a try/except block.
  
  ~~~Python
  try:
    with open('example.txt', r) as file:
        content = file.read()
    except FileNotFoundError:
        print('File does not exist')
  ~~~

- Function arguments and parameters: positional, keyword, positional-only, keyword-only, *args, **kwargs, default params
  1. Provide code examples to illustrate how you can specifically define what kind of arguments a function takes
  2. How can you capture multiple positional and multiple keyword arguments? Describe the asterisk operator in this.
  3. Describe the asterisk operator with regards to iterable unpacking. How does it relate to iterables? Is there a limit to unpacking objects?
  4. Provide a code exampel of extended unpacking. What are the limitations? What about with dictionaries?
  5. What is the difference when using the asterisk operator to unpack vs in a function call? When is a list created and not a tuple?

- Closures
  1. What is the definition of a closure?
  2. How do the scope rules of Python apply to creating closures?
  3. What object is created to manage the free variables within a functions scope? How can you access them?
  4. Provide a code example demonstrating late binding.

- Partial function application
  1. What are the two ways in which partial function application is done in Python?
  2. Provide a code example of partial function application utilizing closure and explain each step of the function execution.
  3. What is the difference between a factory function and a partial function? Provide a code example.

~~~Python
def curry(fn, *cargs, **ckwargs):
    def call_fn(*fargs, **fkwargs):
        d = ckwargs.copy()
        d.update(fkwargs)
        return fn(*(cargs + fargs), **d)
    return call_fn
~~~

- Source: <https://peps.python.org/pep-0309/>

1. Explain the above code example with regards to partial function application and closures

- Decorators
  1. What is the definition of a decorator? What are their purpose?
  2. Discuss the advantages that decorators can provide? Discuss the study of is_prime and lru_cache.
  3. Can decorators be used with only functions? Discuss the differing behavior.
  4. Provide a code example describing the execution behavior of stacked decorators. How does the wrapping differ in defined functions?

- Modules
  1. What is a module object?
  2. How does the from keyword work with regards to imports?
  3. What global variable within modules defines its behavior? What is the difference between a script and a module?
  4. Discuss naming conflicts with regards to imports. What about wildcard imports and namespace pollution?

- Pure functions and side effects
  1. What actions are said to be a side effect? provide a code example for each.
  2. Discuss a major source of bugs in programs and how it related to side effects.
  3. What is the definition of a pure function? Where does lifetime come into play?
  4. Review practice problems on course module.

- Testing terminology
  1. Define the following: test suite, test, assertion

- Writing and running tests with unittest framework
  1. Provide a code example for setting up a basic unit test and describe each of the steps.
  2. What are the various outputs you can receive when running tests?

- Utilizing assertions for testing equality and other conditions: `assertEqual`, `assertIs` etc.
  1. Provide code example of the common assertions available.
  2. What are the two different ways to utilize errors in assertions? How is the with keyword used?
  3. Give code examples of testing equality vs testing values. Why is defining `__eq__` important?

- SEAT appraoch
  1. Define and describe SEAT

- Understanding code coverage
  1. What program is used to get code coverage?
  2. What is code coverage useful for with regards to testing?

- Project directory layout
- Using `pip` for package installation and management
- packaging projects
  1. Describe the layout of what a project looks like and the steps taken to package it. How do you then deliver it to PyPi?
